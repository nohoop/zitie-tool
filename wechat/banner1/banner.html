<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
    <title>公众号封面图（竖图转横图）</title>
    <meta name="color-scheme" content="light dark" />
    <style>
      :root {
        --bg: #f5f5f7;
        --card: #ffffff;
        --text: #1d1d1f;
        --muted: #6e6e73;
        --border: rgba(0, 0, 0, 0.08);
        --shadow: 0 14px 40px rgba(0, 0, 0, 0.1);
        --accent: #007aff;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --bg: #0b0b0c;
          --card: #161618;
          --text: #f5f5f7;
          --muted: #a1a1a6;
          --border: rgba(255, 255, 255, 0.12);
          --shadow: 0 18px 50px rgba(0, 0, 0, 0.35);
        }
      }

      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
      }
      body {
        margin: 0;
        font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "PingFang SC", "Noto Sans SC", sans-serif;
        background: var(--bg);
        color: var(--text);
      }

      .app {
        max-width: 1060px;
        margin: 0 auto;
        padding: 18px 16px 28px;
      }

      header {
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        gap: 12px;
        margin-bottom: 14px;
      }
      h1 {
        margin: 0;
        font-size: 18px;
        letter-spacing: -0.2px;
      }
      .sub {
        margin: 6px 0 0;
        color: var(--muted);
        font-size: 12px;
        line-height: 1.4;
      }

      .actions {
        display: flex;
        gap: 10px;
        align-items: center;
        flex-wrap: wrap;
        justify-content: flex-end;
      }

      .card {
        background: var(--card);
        border: 1px solid var(--border);
        border-radius: 18px;
        box-shadow: var(--shadow);
        overflow: hidden;
      }

      .toolbar {
        display: grid;
        grid-template-columns: 1fr;
        gap: 10px;
        padding: 12px;
        border-top: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.05);
      }

      .grid {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 10px;
      }

      .field {
        grid-column: span 12;
        display: grid;
        gap: 6px;
      }

      label {
        font-size: 12px;
        color: var(--muted);
      }

      input[type="file"] {
        width: 100%;
      }

      select,
      input[type="color"] {
        width: 100%;
        padding: 10px 12px;
        border-radius: 12px;
        border: 1px solid var(--border);
        background: transparent;
        color: var(--text);
        outline: none;
      }
      input[type="color"] {
        padding: 6px;
        height: 42px;
      }

      .btn {
        appearance: none;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.12);
        color: var(--text);
        padding: 10px 12px;
        border-radius: 12px;
        cursor: pointer;
        font-weight: 650;
        font-size: 12px;
      }
      .btn.primary {
        border-color: rgba(0, 122, 255, 0.35);
        background: rgba(0, 122, 255, 0.14);
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      .seg {
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        border: 1px solid var(--border);
        border-radius: 14px;
        overflow: hidden;
      }
      .seg button {
        border: 0;
        padding: 10px 10px;
        background: transparent;
        color: var(--muted);
        cursor: pointer;
        font-weight: 650;
        font-size: 12px;
      }
      .seg button[aria-pressed="true"] {
        background: rgba(0, 122, 255, 0.14);
        color: var(--text);
      }

      .preview {
        padding: 14px;
        display: grid;
        gap: 10px;
      }

      .meta {
        display: flex;
        justify-content: space-between;
        align-items: center;
        gap: 10px;
        flex-wrap: wrap;
      }
      .pill {
        display: inline-flex;
        gap: 8px;
        align-items: center;
        padding: 7px 10px;
        border: 1px solid var(--border);
        border-radius: 999px;
        background: rgba(118, 118, 128, 0.08);
        font-size: 12px;
        color: var(--muted);
      }
      .pill strong {
        color: var(--text);
        font-weight: 750;
      }

      .canvas-wrap {
        border-radius: 18px;
        overflow: hidden;
        border: 1px solid var(--border);
        background: rgba(118, 118, 128, 0.08);
      }
      canvas {
        display: block;
        width: 100%;
        height: auto;
        touch-action: none;
      }

      .status {
        color: var(--muted);
        font-size: 12px;
        line-height: 1.45;
      }

      @media (min-width: 900px) {
        .toolbar .grid {
          gap: 12px;
        }
        .field.sm-6 {
          grid-column: span 6;
        }
        .field.sm-4 {
          grid-column: span 4;
        }
      }

      @media (prefers-reduced-motion: reduce) {
        * {
          scroll-behavior: auto !important;
        }
      }
    </style>
  </head>
  <body>
    <div class="app">
      <header>
        <div>
          <h1>公众号封面图（竖图转横图）</h1>
          <p class="sub">上传人物竖图 → 自动补齐左右背景，并在底部压暗，方便叠加标题文字。</p>
        </div>
        <div class="actions">
          <select id="format" aria-label="下载格式">
            <option value="image/png" selected>PNG</option>
            <option value="image/jpeg">JPG</option>
          </select>
          <button class="btn" id="btnReset" type="button">重置</button>
          <button class="btn primary" id="btnDownload" type="button" disabled>下载</button>
        </div>
      </header>

      <section class="card">
        <div class="preview">
          <div class="meta">
            <div class="pill">尺寸：<strong id="sizeText">900×383</strong></div>
            <div class="pill">拖动人物调整位置（按住 Shift 微调）</div>
          </div>
          <div class="canvas-wrap" id="dropZone" aria-label="drop zone">
            <canvas id="c" width="900" height="383" aria-label="preview canvas"></canvas>
          </div>
          <div class="status" id="status">请上传一张竖图（也支持拖拽到画布）。</div>
        </div>

        <div class="toolbar">
          <div class="grid">
            <div class="field sm-6">
              <label for="file">上传图片</label>
              <input id="file" type="file" accept="image/*" />
            </div>

            <div class="field sm-6">
              <label for="preset">封面尺寸</label>
              <select id="preset">
                <option value="900x383" selected>微信公众号：900×383（推荐）</option>
                <option value="1000x420">2.38:1：1000×420</option>
                <option value="1280x720">16:9：1280×720</option>
              </select>
            </div>

            <div class="field sm-6">
              <label>风格</label>
              <div class="seg" role="group" aria-label="style">
                <button type="button" id="styleAuto" aria-pressed="true">自动</button>
                <button type="button" id="styleSolid" aria-pressed="false">纯色</button>
                <button type="button" id="styleClear" aria-pressed="false">清爽</button>
              </div>
            </div>

            <div class="field sm-6">
              <label>文字可读性（底部压暗）</label>
              <div class="seg" role="group" aria-label="readability">
                <button type="button" id="readNormal" aria-pressed="true">自然</button>
                <button type="button" id="readStrong" aria-pressed="false">加强</button>
                <button type="button" id="readMax" aria-pressed="false">很强</button>
              </div>
            </div>

            <div class="field sm-6">
              <label>人物位置</label>
              <div class="seg" role="group" aria-label="subject position">
                <button type="button" id="posLeft" aria-pressed="false">偏左</button>
                <button type="button" id="posCenter" aria-pressed="true">居中</button>
                <button type="button" id="posRight" aria-pressed="false">偏右</button>
              </div>
            </div>

            <div class="field sm-6" id="bgColorField" style="display: none">
              <label for="bgColor">背景色</label>
              <input id="bgColor" type="color" value="#111111" />
            </div>
          </div>
        </div>
      </section>
    </div>

    <script>
      const els = {
        file: document.getElementById("file"),
        preset: document.getElementById("preset"),
        format: document.getElementById("format"),
        btnReset: document.getElementById("btnReset"),
        btnDownload: document.getElementById("btnDownload"),
        sizeText: document.getElementById("sizeText"),
        status: document.getElementById("status"),
        canvas: document.getElementById("c"),
        dropZone: document.getElementById("dropZone"),
        bgColorField: document.getElementById("bgColorField"),
        bgColor: document.getElementById("bgColor"),
        // style
        styleAuto: document.getElementById("styleAuto"),
        styleSolid: document.getElementById("styleSolid"),
        styleClear: document.getElementById("styleClear"),
        // readability
        readNormal: document.getElementById("readNormal"),
        readStrong: document.getElementById("readStrong"),
        readMax: document.getElementById("readMax"),
        // position
        posLeft: document.getElementById("posLeft"),
        posCenter: document.getElementById("posCenter"),
        posRight: document.getElementById("posRight"),
      };

      const ctx = els.canvas.getContext("2d", { alpha: false, willReadFrequently: true });

      const state = {
        image: null,
        objectUrl: null,
        outW: 900,
        outH: 383,
        style: "auto", // auto | solid | clear
        readability: "normal", // normal | strong | max
        pos: "center", // left | center | right
        offsetX: 0,
        offsetY: 0,
        subjectRect: null,
        dragging: false,
        dragOffsetX: 0,
        dragOffsetY: 0,
      };

      function clamp(value, min, max) {
        return Math.min(max, Math.max(min, value));
      }

      function setPressed(groupEls, activeEl) {
        for (const el of groupEls) el.setAttribute("aria-pressed", el === activeEl ? "true" : "false");
      }

      function setCanvasSize(width, height) {
        state.outW = width;
        state.outH = height;
        els.canvas.width = width;
        els.canvas.height = height;
        els.sizeText.textContent = `${width}×${height}`;
      }

      function coverRect(imgW, imgH, dstW, dstH) {
        const scale = Math.max(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function containRect(imgW, imgH, dstW, dstH) {
        const scale = Math.min(dstW / imgW, dstH / imgH);
        const drawW = imgW * scale;
        const drawH = imgH * scale;
        const x = (dstW - drawW) / 2;
        const y = (dstH - drawH) / 2;
        return { x, y, w: drawW, h: drawH };
      }

      function getBottomLumaEstimate(yStart) {
        const w = els.canvas.width;
        const h = els.canvas.height;
        const y = clamp(Math.floor(yStart), 0, h - 1);
        const hh = clamp(h - y, 1, h);
        const imageData = ctx.getImageData(0, y, w, hh).data;
        const stride = Math.max(4, Math.floor((w * hh) / 42000)) * 4;
        let sum = 0;
        let count = 0;
        for (let i = 0; i < imageData.length; i += stride) {
          const r = imageData[i] / 255;
          const g = imageData[i + 1] / 255;
          const b = imageData[i + 2] / 255;
          sum += 0.2126 * r + 0.7152 * g + 0.0722 * b;
          count += 1;
        }
        return count ? sum / count : 0.5;
      }

      function baseSubjectCenter() {
        const w = els.canvas.width;
        const h = els.canvas.height;
        const x = state.pos === "left" ? w * 0.37 : state.pos === "right" ? w * 0.63 : w * 0.5;
        const y = h * 0.52;
        return { x, y };
      }

      function getReadabilityBase() {
        // Tuned for "文字叠在底部" 的常见封面视觉。
        if (state.readability === "max") return { baseStrength: 0.76, start: 0.5 };
        if (state.readability === "strong") return { baseStrength: 0.62, start: 0.53 };
        return { baseStrength: 0.48, start: 0.56 };
      }

      function render({ applyAutoReadability = true } = {}) {
        const img = state.image;
        const w = els.canvas.width;
        const h = els.canvas.height;
        ctx.save();
        ctx.clearRect(0, 0, w, h);

        if (!img) {
          ctx.fillStyle = "rgba(118,118,128,0.10)";
          ctx.fillRect(0, 0, w, h);
          ctx.fillStyle = "rgba(110,110,115,0.9)";
          ctx.font = `650 ${Math.round(Math.min(w, h) * 0.06)}px -apple-system, BlinkMacSystemFont, "PingFang SC", sans-serif`;
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("上传图片开始", w / 2, h / 2);
          ctx.restore();
          return;
        }

        // Background (Apple-ish: soft, clean).
        if (state.style === "solid") {
          ctx.fillStyle = els.bgColor.value || "#111111";
          ctx.fillRect(0, 0, w, h);
        } else {
          const r = coverRect(img.naturalWidth, img.naturalHeight, w, h);
          const blurPx = state.style === "clear" ? 10 : 18;
          const zoom = state.style === "clear" ? 1.035 : 1.06;
          ctx.save();
          ctx.filter = blurPx > 0 ? `blur(${blurPx}px)` : "none";
          ctx.translate(w / 2, h / 2);
          ctx.scale(zoom, zoom);
          ctx.translate(-w / 2, -h / 2);
          ctx.drawImage(img, r.x, r.y, r.w, r.h);
          ctx.restore();

          // Overall dim: keep "clear" lighter.
          const dim = state.style === "clear" ? 0.06 : 0.14;
          ctx.fillStyle = `rgba(0,0,0,${dim})`;
          ctx.fillRect(0, 0, w, h);
        }

        // Subject (portrait) — auto sizing, minimal knobs.
        const targetH = h * 0.94;
        const subject = containRect(img.naturalWidth, img.naturalHeight, w, targetH);
        const base = baseSubjectCenter();
        const centerX = base.x + state.offsetX;
        const centerY = base.y + state.offsetY;
        const sx = Math.round(centerX - subject.w / 2);
        const sy = Math.round(centerY - subject.h / 2);
        state.subjectRect = { x: sx, y: sy, w: subject.w, h: subject.h, cx: centerX, cy: centerY };

        ctx.save();
        ctx.shadowColor = "rgba(0,0,0,0.33)";
        ctx.shadowBlur = 18;
        ctx.shadowOffsetY = 7;
        ctx.drawImage(img, sx, sy, subject.w, subject.h);
        ctx.restore();

        // Bottom readability gradient (auto-adjust based on bottom brightness).
        const { baseStrength, start } = getReadabilityBase();
        let strength = baseStrength;
        const startPx = start * h;
        if (applyAutoReadability) {
          const luma = getBottomLumaEstimate(startPx);
          const target = 0.34;
          const extra = clamp((luma - target) / 0.85, 0, 1) * 0.26;
          strength = clamp(strength + extra, 0, 0.92);
        }
        const g = ctx.createLinearGradient(0, startPx, 0, h);
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, `rgba(0,0,0,${strength})`);
        ctx.fillStyle = g;
        ctx.fillRect(0, startPx, w, h - startPx);

        ctx.restore();
      }

      function updateUI() {
        els.btnDownload.disabled = !state.image;
        els.bgColorField.style.display = state.style === "solid" ? "grid" : "none";
        els.status.textContent = state.image
          ? "拖动人物调整位置，满意后点击下载。"
          : "请上传一张竖图（也支持拖拽到画布）。";
      }

      async function loadImageFromFile(file) {
        if (!file) return;
        if (state.objectUrl) URL.revokeObjectURL(state.objectUrl);
        state.objectUrl = URL.createObjectURL(file);
        const img = new Image();
        img.decoding = "async";
        img.src = state.objectUrl;
        await img.decode();
        state.image = img;
        state.offsetX = 0;
        state.offsetY = 0;
      }

      function applyPreset() {
        const [w, h] = els.preset.value.split("x").map((v) => Number(v));
        setCanvasSize(w, h);
      }

      function syncAndRender({ applyAutoReadability = true } = {}) {
        applyPreset();
        render({ applyAutoReadability });
        updateUI();
      }

      function download() {
        if (!state.image) return;
        const format = els.format.value;
        const ext = format === "image/jpeg" ? "jpg" : "png";
        const name = `wechat-cover-${state.outW}x${state.outH}.${ext}`;
        const url = els.canvas.toDataURL(format, format === "image/jpeg" ? 0.92 : undefined);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        document.body.appendChild(a);
        a.click();
        a.remove();
      }

      function reset() {
        els.preset.value = "900x383";
        els.format.value = "image/png";
        els.bgColor.value = "#111111";
        state.style = "auto";
        state.readability = "normal";
        state.pos = "center";
        state.offsetX = 0;
        state.offsetY = 0;

        setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleAuto);
        setPressed([els.readNormal, els.readStrong, els.readMax], els.readNormal);
        setPressed([els.posLeft, els.posCenter, els.posRight], els.posCenter);

        if (state.objectUrl) URL.revokeObjectURL(state.objectUrl);
        state.objectUrl = null;
        state.image = null;
        els.file.value = "";
        syncAndRender();
      }

      function eventToCanvasPoint(e) {
        const rect = els.canvas.getBoundingClientRect();
        const scaleX = els.canvas.width / rect.width;
        const scaleY = els.canvas.height / rect.height;
        return { x: (e.clientX - rect.left) * scaleX, y: (e.clientY - rect.top) * scaleY };
      }

      function hitTestSubject(pt) {
        const r = state.subjectRect;
        if (!r) return false;
        return pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      }

      function onPointerDown(e) {
        if (!state.image) return;
        const pt = eventToCanvasPoint(e);
        if (!hitTestSubject(pt)) return;
        e.preventDefault();
        els.canvas.setPointerCapture(e.pointerId);
        state.dragging = true;
        const base = baseSubjectCenter();
        const centerX = base.x + state.offsetX;
        const centerY = base.y + state.offsetY;
        state.dragOffsetX = pt.x - centerX;
        state.dragOffsetY = pt.y - centerY;
      }

      function onPointerMove(e) {
        if (!state.dragging) return;
        const pt = eventToCanvasPoint(e);
        const fine = e.shiftKey ? 0.35 : 1;
        const base = baseSubjectCenter();
        const nextCenterX = pt.x - state.dragOffsetX;
        const nextCenterY = pt.y - state.dragOffsetY;
        const nextOffsetX = nextCenterX - base.x;
        const nextOffsetY = nextCenterY - base.y;
        state.offsetX = state.offsetX * (1 - fine) + nextOffsetX * fine;
        state.offsetY = state.offsetY * (1 - fine) + nextOffsetY * fine;
        render({ applyAutoReadability: false });
      }

      function onPointerUp(e) {
        if (!state.dragging) return;
        state.dragging = false;
        try {
          els.canvas.releasePointerCapture(e.pointerId);
        } catch {}
        render({ applyAutoReadability: true });
      }

      // Events.
      els.file.addEventListener("change", async () => {
        const file = els.file.files && els.file.files[0];
        if (!file) return;
        try {
          await loadImageFromFile(file);
          syncAndRender();
        } catch (err) {
          console.error(err);
          els.status.textContent = "图片加载失败，请换一张试试。";
        }
      });

      els.dropZone.addEventListener("dragover", (e) => {
        e.preventDefault();
      });
      els.dropZone.addEventListener("drop", async (e) => {
        e.preventDefault();
        const file = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
        if (!file) return;
        try {
          await loadImageFromFile(file);
          syncAndRender();
        } catch (err) {
          console.error(err);
          els.status.textContent = "图片加载失败，请换一张试试。";
        }
      });

      els.preset.addEventListener("change", () => {
        state.offsetX = 0;
        state.offsetY = 0;
        syncAndRender({ applyAutoReadability: true });
      });
      els.format.addEventListener("change", () => updateUI());
      els.bgColor.addEventListener("input", () => syncAndRender({ applyAutoReadability: false }));

      els.btnDownload.addEventListener("click", download);
      els.btnReset.addEventListener("click", reset);

      els.canvas.addEventListener("pointerdown", onPointerDown);
      els.canvas.addEventListener("pointermove", onPointerMove);
      els.canvas.addEventListener("pointerup", onPointerUp);
      els.canvas.addEventListener("pointercancel", onPointerUp);
      window.addEventListener("resize", () => render({ applyAutoReadability: false }));

      function hookSeg() {
        // Style
        els.styleAuto.addEventListener("click", () => {
          state.style = "auto";
          setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleAuto);
          syncAndRender();
        });
        els.styleSolid.addEventListener("click", () => {
          state.style = "solid";
          setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleSolid);
          syncAndRender({ applyAutoReadability: false });
        });
        els.styleClear.addEventListener("click", () => {
          state.style = "clear";
          setPressed([els.styleAuto, els.styleSolid, els.styleClear], els.styleClear);
          syncAndRender();
        });

        // Readability
        els.readNormal.addEventListener("click", () => {
          state.readability = "normal";
          setPressed([els.readNormal, els.readStrong, els.readMax], els.readNormal);
          syncAndRender();
        });
        els.readStrong.addEventListener("click", () => {
          state.readability = "strong";
          setPressed([els.readNormal, els.readStrong, els.readMax], els.readStrong);
          syncAndRender();
        });
        els.readMax.addEventListener("click", () => {
          state.readability = "max";
          setPressed([els.readNormal, els.readStrong, els.readMax], els.readMax);
          syncAndRender();
        });

        // Position
        els.posLeft.addEventListener("click", () => {
          state.pos = "left";
          state.offsetX = 0;
          state.offsetY = 0;
          setPressed([els.posLeft, els.posCenter, els.posRight], els.posLeft);
          syncAndRender({ applyAutoReadability: false });
        });
        els.posCenter.addEventListener("click", () => {
          state.pos = "center";
          state.offsetX = 0;
          state.offsetY = 0;
          setPressed([els.posLeft, els.posCenter, els.posRight], els.posCenter);
          syncAndRender({ applyAutoReadability: false });
        });
        els.posRight.addEventListener("click", () => {
          state.pos = "right";
          state.offsetX = 0;
          state.offsetY = 0;
          setPressed([els.posLeft, els.posCenter, els.posRight], els.posRight);
          syncAndRender({ applyAutoReadability: false });
        });
      }

      hookSeg();
      reset();
    </script>
  </body>
</html>
